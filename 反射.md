* 定义：Java 语言中的一种 动态（运行时）访问，检测&修改它本身的能力
* 作用：动态（运行时）获取类的完整结构信息& 调用对象的方法


* 特点
> 1 优点
  灵活性高，因为反射属于动态编译，即只有到运行时才动态创建 &获取对象实例

>编译方式说明：静态编译：在编译时确定类型 & 绑定对象。如常见的使用new关键字创建对象
动态编译：运行时确定类型 & 绑定对象。动态编译体现了Java的灵活性、多态特性 & 降低类之间的藕合性

-------
> 2 缺点  
执行效率低
1.因为反射的操作 主要通过JVM执行，所以时间成本会 高于 直接执行相同操作 

>2.因为接口的通用性，Java的invoke方法是传object和object[]数组的。基本类型参数需要装箱和拆箱，产生大量额外的对象和内存开销，频繁促发GC。

>3.编译器难以对动态调用的代码提前做优化，比如方法内联。
反射需要按名检索类和方法，有一定的时间开销。
> * 容易破坏类结构： 因为反射操作饶过了源码，容易干扰类原有的内部逻辑

---------
![Image text](https://github.com/flowerflowerflower/javalearn/blob/master/image/1560349418.jpg?raw=true)



###  实现手段
* 定义：java.lang.Class类是反射机制的基础
* 作用：存放着对应类型对象的 运行时信息

>1. 在Java程序运行时，Java虚拟机为所有类型维护一个java.lang.Class对象 
>2. 该Class对象存放着所有关于该对象的 运行时信息
>3. 泛型形式为Class<T>

* 每种类型的Class对象只有1个 = 地址只有1个
```
// 对于2个String类型对象，它们的Class对象相同
Class c1 = "Carson".getClass();
Class c2 =  Class.forName("java.lang.String");
// 用==运算符实现两个类对象地址的比较
System.out.println(c1 ==c2);
// 输出结果：true
```

* Java反射机制的实现除了依靠Java.lang.Class类，还需要依靠：Constructor类、Field类、Method类，分别作用于类的各个组成部分：


![Image text](https://github.com/flowerflowerflower/javalearn/blob/master/image/1560351932.png?raw=true)



### 使用步骤
在使用Java反射机制时，主要步骤包括
1. 获取 目标类型的class 对象
2. 通过 Class 对象分别获取Constructor类对象、Method类对象 & Field 类对象
3. 通过 Constructor类对象、Method类对象 & Field类对象分别获取类的构造函数、方法&属性的具体信息，并进行后续操作

下面，我将详细讲解每个步骤中的使用方法。

#### 步骤1：获取 目标类型的Class对象

```
// 获取 目标类型的`Class`对象的方式主要有4种

<-- 方式1：Object.getClass() -->
    // Object类中的getClass()返回一个Class类型的实例 
    Boolean carson = true; 
    Class<?> classType = carson.getClass(); 
    System.out.println(classType);
    // 输出结果：class java.lang.Boolean  

<-- 方式2：T.class 语法    -->
    // T = 任意Java类型
    Class<?> classType = Boolean.class; 
    System.out.println(classType);
    // 输出结果：class java.lang.Boolean  
    // 注：Class对象表示的是一个类型，而这个类型未必一定是类
    // 如，int不是类，但int.class是一个Class类型的对象

<-- 方式3：static method Class.forName   -->
    Class<?> classType = Class.forName("java.lang.Boolean"); 
    // 使用时应提供异常处理器
    System.out.println(classType);
    // 输出结果：class java.lang.Boolean  

<-- 方式4：TYPE语法  -->

    Class<?> classType = Boolean.TYPE; 
    System.out.println(classType);
    // 输出结果：boolean  
```
此处额外讲一下java.lang.reflect.Type类

* java.lang.reflect.Type是 Java中所有类型的父接口
这些类型包括:
