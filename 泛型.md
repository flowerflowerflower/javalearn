## 简单介绍
1. 抽象代替具体
2. 泛型只是在编译器有效

### 为什么只在编译器有效呢？
> Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出,并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段

### 泛型的使用
> 泛型有三种使用方式,分别为：泛型类，泛型方法，泛型接口

1. 泛型类
> class 类名称 <泛型标识：可以随便写任意标识号，标识指定的泛型的类型>{
  private 泛型标识 /*（成员变量类型）*/ var; 
  .....

  }
}
>>
* . 泛型类型参数只能是类类型，不能是简单的类型
* 不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。


## 接口泛型
> 泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中

## 泛型方法

~~~ 
/**
  泛型方法的基本介绍
  @param tClass 传入的泛型实参
  @return T 返回值为T类型
  说明：
      1）public 与 返回值中间<T>非常重要，可以理解为声明此方法为泛型方法。
      
      2）只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方
      法。
      3）<T>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。
      4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。
 */
public <T> T genericMethod(Class<T> tClass)throws InstantiationException ,
  IllegalAccessException{
        T instance = tClass.newInstance();
        return instance;
}
~~~

内容很多重点可以见博客  https://www.cnblogs.com/coprince/p/8603492.html


## 总结
> 一般使用的泛型 用于 输入和输出 相关信息
















